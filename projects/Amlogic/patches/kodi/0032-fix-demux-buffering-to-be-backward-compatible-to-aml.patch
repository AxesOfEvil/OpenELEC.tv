From 15a65cb69b1b19728b2d4e4607f7bf22c50d29ff Mon Sep 17 00:00:00 2001
From: davilla <davilla@4pi.com>
Date: Mon, 16 Feb 2015 09:16:31 -0500
Subject: [PATCH 32/32] fix demux buffering to be backward compatible to aml
 kernels without buffering support

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp |  114 ++++++++++++++++-----
 xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.h   |    2 +
 2 files changed, 92 insertions(+), 24 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
index 295f36f..00be24c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
@@ -141,12 +141,19 @@ class DllLibAmCodec : public DllDynamic, DllLibamCodecInterface
     RESOLVE_METHOD(codec_set_cntl_syncthresh)
 
     RESOLVE_METHOD(codec_set_av_threshold)
-    RESOLVE_METHOD(codec_set_video_delay_limited_ms)
-    RESOLVE_METHOD(codec_get_video_delay_limited_ms)
-    RESOLVE_METHOD(codec_get_video_cur_delay_ms)
   END_METHOD_RESOLVE()
 
 public:
+  bool LoadVideoDelayFunctions()
+  {
+    // added in amcodec/jellybean, manually load them so we do not fault.
+    int rtn;
+    rtn  = m_dll->ResolveExport("codec_set_video_delay_limited_ms", (void**)&m_codec_set_video_delay_limited_ms_ptr, false);
+    rtn &= m_dll->ResolveExport("codec_get_video_delay_limited_ms", (void**)&m_codec_get_video_delay_limited_ms_ptr, false);
+    rtn &= m_dll->ResolveExport("codec_get_video_cur_delay_ms",(void**)&m_codec_get_video_cur_delay_ms_ptr, false);
+    return(rtn == 1);
+  }
+
   void codec_init_para(aml_generic_param *p_in, codec_para_t *p_out)
   {
     memset(p_out, 0x00, sizeof(codec_para_t));
@@ -1362,6 +1369,7 @@ CAMLCodec::CAMLCodec() : CThread("CAMLCodec")
   memset(am_private, 0, sizeof(am_private_t));
   m_dll = new DllLibAmCodec;
   m_dll->Load();
+  m_dll_has_video_delay = m_dll->LoadVideoDelayFunctions();
   am_private->m_dll = m_dll;
 }
 
@@ -1381,6 +1389,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
 #endif
 
   m_speed = DVD_PLAYSPEED_NORMAL;
+  m_1st_pts = 0;
   m_cur_pts = 0;
   m_cur_pictcnt = 0;
   m_old_pictcnt = 0;
@@ -1574,7 +1583,8 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
   // make sure we are not stuck in pause (amcodec bug)
   m_dll->codec_resume(&am_private->vcodec);
   m_dll->codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
-  m_dll->codec_set_video_delay_limited_ms(&am_private->vcodec, 1000);
+  if (m_dll_has_video_delay)
+    m_dll->codec_set_video_delay_limited_ms(&am_private->vcodec, 1000);
 
   m_dll->codec_set_cntl_avthresh(&am_private->vcodec, AV_SYNC_THRESH);
   m_dll->codec_set_cntl_syncthresh(&am_private->vcodec, 0);
@@ -1672,7 +1682,8 @@ void CAMLCodec::Reset()
   }
   // reset the decoder
   m_dll->codec_reset(&am_private->vcodec);
-  m_dll->codec_set_video_delay_limited_ms(&am_private->vcodec, 1000);
+  if (m_dll_has_video_delay)
+    m_dll->codec_set_video_delay_limited_ms(&am_private->vcodec, 1000);
   dumpfile_close(am_private);
   dumpfile_open(am_private);
 
@@ -1686,6 +1697,7 @@ void CAMLCodec::Reset()
   aml_set_sysfs_int("/sys/class/video/blackout_policy", blackout_policy);
 
   // reset some interal vars
+  m_1st_pts = 0;
   m_cur_pts = 0;
   m_cur_pictcnt = 0;
   m_old_pictcnt = 0;
@@ -1758,29 +1770,70 @@ int CAMLCodec::Decode(uint8_t *pData, size_t iSize, double dts, double pts)
       if (am_private->am_pkt.isvalid)
         CLog::Log(LOGDEBUG, "CAMLCodec::Decode: write_av_packet looping");
     }
+    if (!m_dll_has_video_delay)
+    {
+      // if we seek, then GetTimeSize is wrong as
+      // reports lastpts - cur_pts and hw decoder has
+      // not started outputing new pts values yet.
+      // so we grab the 1st pts sent into driver and
+      // use that to calc GetTimeSize.
+      if (m_1st_pts == 0)
+        m_1st_pts = am_private->am_pkt.lastpts;
+    }
   }
 
-  // we must wait here or we can consume
-  // all buffered dvd player video demux packets.
-  // wait long if hw buffers greater than our limit.
-  // wait short if not.
-  int wait_time = 25;
-  if (GetTimeSize() > 1.0)
-    wait_time = 100;
-  m_ready_event.Reset();
-  m_ready_event.WaitMSec(wait_time);
-
   // we must return VC_BUFFER or VC_PICTURE,
   // default to VC_BUFFER.
   int rtn = VC_BUFFER;
-  if (m_old_pictcnt != m_cur_pictcnt)
+  if (m_dll_has_video_delay)
   {
-    m_old_pictcnt++;
-    rtn = VC_PICTURE;
-    // we got a new pict, try to keep hw buffered demux around 1 second.
-    if (GetTimeSize() < 1.0)
-      rtn |= VC_BUFFER;
+    // we must wait here or we can consume
+    // all buffered dvd player video demux packets.
+    // wait long if hw buffers greater than our limit.
+    // wait short if not.
+    int wait_time = 25;
+    if (GetTimeSize() > 1.0)
+      wait_time = 100;
+    m_ready_event.Reset();
+    m_ready_event.WaitMSec(wait_time);
+
+    if (m_old_pictcnt != m_cur_pictcnt)
+    {
+      m_old_pictcnt++;
+      rtn = VC_PICTURE;
+      // we got a new pict, try to keep hw buffered demux around 1 second.
+      if (GetTimeSize() < 1.0)
+        rtn |= VC_BUFFER;
+    }
+  }
+  else
+  {
+    // if we have still frames, demux size will be small
+    // and we need to pre-buffer more.
+    double target_timesize = 1.0;
+    if (iSize < 20)
+      target_timesize = 2.0;
+
+    // keep hw buffered demux above 1 second
+    if (GetTimeSize() < target_timesize && m_speed == DVD_PLAYSPEED_NORMAL)
+      return VC_BUFFER;
+
+    // wait until we get a new frame or 25ms,
+    if (m_old_pictcnt == m_cur_pictcnt)
+      m_ready_event.WaitMSec(25);
+
+    if (m_old_pictcnt != m_cur_pictcnt)
+    {
+      m_old_pictcnt++;
+      rtn = VC_PICTURE;
+      // we got a new pict, try and keep hw buffered demux above 2 seconds.
+      // this, combined with the above 1 second check, keeps hw buffered demux between 1 and 2 seconds.
+      // we also check to make sure we keep from filling hw buffer.
+      if (GetTimeSize() < 2.0 && GetDataSize() < m_vbufsize/3)
+        rtn |= VC_BUFFER;
+    }
   }
+
 /*
   CLog::Log(LOGDEBUG, "CAMLCodec::Decode: "
     "rtn(%d), m_cur_pictcnt(%lld), m_cur_pts(%f), lastpts(%f), GetTimeSize(%f), GetDataSize(%d)",
@@ -1866,9 +1919,22 @@ double CAMLCodec::GetTimeSize()
   if (!m_opened)
     return 0;
 
-  int video_delay_ms;
-  if (m_dll->codec_get_video_cur_delay_ms(&am_private->vcodec, &video_delay_ms) >= 0)
-    m_timesize = (float)video_delay_ms / 1000.0;
+  if (m_dll_has_video_delay)
+  {
+    int video_delay_ms;
+    if (m_dll->codec_get_video_cur_delay_ms(&am_private->vcodec, &video_delay_ms) >= 0)
+      m_timesize = (float)video_delay_ms / 1000.0;
+  }
+  else
+  {
+    // if m_cur_pts is zero, hw decoder was not started yet
+    // so we use the pts of the 1st demux packet that was send
+    // to hw decoder to calc timesize.
+    if (m_cur_pts == 0)
+      m_timesize = (double)(am_private->am_pkt.lastpts - m_1st_pts) / PTS_FREQ;
+    else
+      m_timesize = (double)(am_private->am_pkt.lastpts - m_cur_pts) / PTS_FREQ;
+  }
 
   // lie to DVDPlayer, it is hardcoded to a max of 8 seconds,
   // if you buffer more than 8 seconds, it goes nuts. We need
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.h
index e6a2848..dc58527 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.h
@@ -66,10 +66,12 @@ private:
   static void   RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect);
 
   DllLibAmCodec   *m_dll;
+  bool             m_dll_has_video_delay;
   bool             m_opened;
   am_private_t    *am_private;
   CDVDStreamInfo   m_hints;
   volatile int     m_speed;
+  volatile int64_t m_1st_pts;
   volatile int64_t m_cur_pts;
   volatile int64_t m_cur_pictcnt;
   volatile int64_t m_old_pictcnt;
-- 
1.7.10.4

